 
# String, StringBuilder, StringBuffer 의 차이 (성능, 문법)
---------------


자바에서 String과 StringBuffer, StringBuilder의 차이점을 알아보자. 이들의 공통점은 모두 String(문자열)을 저장하고 관리하는 클래스라는 것이다.


String은 immutable(불변)하고 StringBuffer, StringBuilder는 mutable(가변)하다. 이를 쉽게 말하면, String을 리터럴로 생성하면 그 인스턴스의 메모리 공간은 변하지 않는다.


```JAVA


String literal="literal"; // 리터럴로 생성


String new=new String("new"); // new로 생성

```


위 코드에서 두 가지의 String class 생성 방식이 있는데, 두 방식 모두 JVM 메모리에서 힙 영역에 생성된다는 점은 같다. 하지만 리터럴로 생성하면 특수하게 "String Pool"이라는 공간에서 생성된다. 이 메모리 공간에 생성된 문자열 값은 절대 변하지 않는다는 말이다.

그래서, '+' 연산이나 .concat() 메소드를 이용하여 문자열 값에 변화를 줘도 메모리 공간 내의 값이 변하는 것이 아니라, "String Pool"이라는 공간안에 메모리를 할당받아 새로운 String 클래스 객체를 만들어서 문자열을 나타내는 것이다.

이렇게 새로운 문자열이 만들어지면 '기존의 문자열'은 가비지 콜렉터에 의해 제거되야 하는 단점이 있다.

또한, 이러한 문자열 연산이 많아진다면 연산을 한번 할 때마다 계속해서 문자열 객체를 만드는 오버헤드가 발생하므로 성능이 떨어질 수밖에 없다. 대신에 String 클래스의 객체는 불변하기 때문에 단순하게 읽어가는 조회 연산에서는 타 클래스보다 빠르게 읽을 수 있는 장점이 있다.

String 클래스는 문자열 연산이 적고, 자주 조회하는 경우에 사용하면 좋다. 또한, 불변하기 때문에 멀티 쓰레드 환경에서 동기화를 신경 쓰지 않아도 된다.
 

StringBuffer와 StringBuilder 클래스는 String과 다르게 mutable하다. 즉 문자열 연산을 할 때, 클래스는 한 번만 만들고(new), 메모리의 값을 변경시켜서 문자열을 변경한다.

따라서, 문자열 연산이 많을 때 사용하면 성능이 좋다. 또한 두 클래스의 메서드들이 같아서 호환이 가능하다.
두 클래스의 차이점은 StringBuffer는 멀티 쓰레드 환경에서 synchronized 키워드가 가능하므로 동기화가 가능하다. 즉, thread-safe하다. 반대로, StringBuilder는 thread-safe하지 않다.
동기화가 가능하다는 것은 멀티스레드 환경을 지원한다는 것이다.

* 동기화: A스레드와 B스레드가 한 객체를 작업중일 때, A가 값을 바꿔버리면 B가 엉뚱한 값으로 작업을 시도할 수 있다. 여러 스레드가 한 자원을 사용하려고 할 때 다른 스레드의 접근을 막는 것을 동기화라 한다. 데이터의 무결성을 보장해준다.

StringBuilder는 동기화를 지원하지 않기 때문에 멀티 쓰레드 환경에서는 적합하지 않다.
대신, 동기화를 고려하지 않으므로 싱글 쓰레드 환경에서 StringBuffer에 비해 연산처리가 빠른 장점이 있다.


아래는 각 클래스 별 성능을 나타낸 그림이다.

 ![A](https://github.com/dpfkdlemtp/JavaStudy/blob/image/String%20%EC%84%B1%EB%8A%A5%EB%B9%84%EA%B5%90.png)


정리해보면 각 상황에 맞게 쓰는 클래스는 다음과 같다.

* String                :  문자열 연산이 적고 멀티쓰레드 환경일 경우
* StringBuffer     :  문자열 연산이 많고 멀티쓰레드 환경일 경우
* StringBuilder   :  문자열 연산이 많고 단일쓰레드이거나 동기화를 고려하지 않아도 되는 경우





