 
# JVM 동작 원리
---------------

![A](https://github.com/dpfkdlemtp/JavaStudy/blob/image/Java%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EB%8F%99%EC%9E%91.png)

	그림 출처: https://swk3169.tistory.com/181

자바 프로그램의 클래스 파일들은 OS에서 동작하는 것이 아닌 JVM(Java Vritual Machine)상에서 동작한다. 따라서, JVM은 OS에 독립적이다. JVM은 자바 소스코드 컴파일 후 생성된 파일이 Interpret과 Link 없이 바로 JVM에 적재되고, OS로부터 메모리를 할당 받아서 GC(Garbage Collection)을 통해 스스로 메모리를 관리한다는 특징이 있다. 또한, 자바 프로그램은 일반 프로그램보다 한 단계를 더 거치므로, 상대적으로 실행 속도가 느리다는 단점이 있다.


![B](https://github.com/dpfkdlemtp/JavaStudy/blob/image/Java%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%EB%8F%99%EC%9E%912.png)
 
	그림 출처: https://swk3169.tistory.com/181

1. 작성한 자바 소스(.java)를 자바 컴파일러를 통해서 자바 바이트 코드(.class)로 컴파일 한다.

	###### 자바 바이트 코드: JVM이 이해할 수 있는 코드로 컴퓨터가 읽을 수 없는 반기계어이다. 자바 바이트 코드의 각 명령어는 1바이트 크기의 Opcode와 추가 피연산자로 이루어져있다.

2. 컴파일된 바이트코드를 JVM의 클래스 로더에게 전달한다.
	###### 클래스 로더 세부 동작

	1. 로드: 클래스 파일을 가져와서 JVM의 메모리에 로드한다.
	2. 검증: 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된대로 구성되어 있는지 검사한다.
	3. 준비: 클래스가 필요로 하는 메모리를 할당한다. (필드, 메서드, 인터페이스 등등)
	4. 분석: 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.
	5. 초기화: 클래스 변수들을 적절한 값으로 초기화한다. (static 필드들을 설정된 값으로 초기화 등)
	#
3. JVM의 클래스 로더는 동적 로딩(Dynamic Loading)을 통해 필요한 클래스들을 로딩 및 링크하여 런타임 데이터 영역(Runtime Data Arae), 즉 JVM의 메모리에 올린다.
4. 실행 엔진(Execution Engine)은 JVM 메모리에 올라온 바이트 코드들을 명령어 단위로 하나씩 가져와서 실행한다. 이때, 실행 엔진은 2가지 방식으로 동작한다.
	1. 자바 인터프리터: 바이트 코드 명령어를 하나씩 읽어서 해석하고 실행한다. 하나하나의 실행은 빠르나, 전체적인 실행 속도가 느리다는 단점이 있다.
	2. JIT 컴파일러(Just-In-Time Compiler): 인터프리터의 단점을 보완하기 위해 도입된 방식으로 바이트 코드 전체를 컴파일하여 바이너리 코드로 변경하고 이후에는 해당 메서드를 더이상 인터프리팅 하지 않고, 바이너리 코드로 직접 실행하는 방식이다. 하나씩 인터프리팅하여 실행하는 것이 아니라 바이트 코드 전체가 컴파일된 바이너리 코드를 실행하는 것이기 때문에 전체적인 실행속도는 인터프리팅 방식보다 빠르다.
	#

* 때에 따라 가비지 컬렉터가 메모리 관리 기능을 자동으로 수행한다. 더 이상 사용되지 않는 객체를 해제시켜 메모리를 자동으로 반납한다.

